\documentclass[10pt,conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage[numbers]{natbib}
\usepackage{filecontents}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{comment}
\usepackage{stmaryrd}
\usepackage{pifont}% http://ctan.org/pkg/pifont
\newtheorem{definition}{Definition}
\usepackage{tikz}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{csquotes}
\usepackage{varwidth}
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\newcommand{\anynotevent}[1]{{\textcolor{darkred}
{{\textbf{\footnotesize $\overline{\text{#1}}$}}}}}
\newcommand{\env}{\code{\mathcal{V}}}
\newcommand{\es}{\theta}
\newcommand{\ev}{ev}
\newcommand{\siderule}[1]{
\code{\footnotesize{\textcolor{mGray}{#1}}}}
\usepackage{adjustbox}
\usepackage{ebproof}
\usepackage{cancel}
\newcommand{\CONTAIN}{\sqsubseteq}
\definecolor{mypink}{RGB}{219, 48, 122}
\definecolor{darklavender}{rgb}{0.45, 0.31, 0.59}
\definecolor{deepcerise}{rgb}{0.85, 0.2, 0.53}
\def\defeq{\ensuremath{\,\triangleq}}
\definecolor{darkred}{rgb}{0.55, 0.0, 0.0}
\newcommand{\anyevent}[1]{{\textcolor{darkred}
{{\textbf{\small #1}}}}}
\newcommand\figref[1]{Fig. \textcolor{black}{\ref{#1}}.}
\newcommand\tabref[1]{Table \textcolor{black}{\ref{#1}}}
\newcommand\secref[1]{Sec. \textcolor{black}{\ref{#1}}}
\newcommand{\timedL}{\code{C^{t}}}

\newcommand\theoref[1]{Theorem~\textcolor{blue}{\ref{#1}}}
\newcommand\lemmaref[1]{Lemma~\textcolor{blue}{\ref{#1}}}
\newcommand\appref[1]{Appendix~\textcolor{blue}{\ref{#1}}}
\newcommand\defref[1]{Definition~\textcolor{blue}{\ref{#1}}}
\newcommand\algoref[1]{Algorithm~\textcolor{blue}{\ref{#1}}}
\newcommand{\code}[1]{{\tt{\ensuremath{\m{#1}}}}}
\newcommand{\m}{\mathit} 
\newcommand{\lappend}{\mathrel{\texttt{++}}}
\definecolor{mGray}{rgb}{0.4,0.4,0.4}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{huntergreen}{rgb}{0.33, 0.42, 0.18}

\newcommand{\mysharp}{{\mathrel{\texttt{\#}}}}
\newcommand{\timedEffects}{\emph{TimEffs}}
\usepackage{wrapfig}
\newcommand{\effect}{{\ensuremath{\mathrm{\Phi}}}}
\usepackage{listings}  

\lstdefinelanguage{JavaScript}{
  keywords={typeof, void, const, new, int, catch, function, return, null, catch, switch, var,async, await, if, setTimeout, this, then, while, post, else, case, break, return},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean,event, timeout, deadline, delay,  throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{darklavender}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JavaScript,
   %%backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
%frame=single
numbers=left,   
xleftmargin=1em, 
    numberstyle=\tiny\color{mGray},
   numbersep=10pt,
   tabsize=4,
   breaklines=true,
   showtabs=false,
   captionpos=b,
   keywordstyle=[2]\color{purple}\bfseries, %
   morekeywords=[2]{do, hiphop,every, loop,suspend, when, signal, end, present, nothing, emit,in, out, yield,abort, fork, par, run},
}




\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Automated Verification for Real-Time Systems 
using Implicit Clocks and an Extended Antimirov Algorithm}


\author{(Anonymous Authors)}


\begin{comment}
\author{\IEEEauthorblockN{1\textsuperscript{st} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
\and
\IEEEauthorblockN{3\textsuperscript{rd} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
\and
\IEEEauthorblockN{4\textsuperscript{th} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
\and
\IEEEauthorblockN{5\textsuperscript{th} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
\and
\IEEEauthorblockN{6\textsuperscript{th} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
}
\end{comment}
\pagestyle{plain}
\maketitle

\begin{abstract}
    The correctness of real-time systems 
    depends both on the correct functionalities and the realtime constraints.
    To go beyond the existing Timed Automata based techniques, 
    we propose a novel solution that integrates a 
    modular Hoare-style forward verifier with a new term rewriting 
    system (TRS) on \emph{Timed Effects} (\timedEffects).
    The main purposes are to increase the expressiveness,  
    dynamically create clocks, 
    and efficiently solve constraints on the clocks.  
    We formally define 
    a core language \timedL, generalizing the real-time systems, modeled 
    using mutable variables and timed behavioral patterns, 
    such as \emph{delay}, \emph{timeout}, \emph{interrupt}, \emph{deadline}. 
    Secondly, to capture real-time specifications, 
    we introduce \timedEffects, a new effects logic, 
    that extends 
    \emph{Regular Expressions} with dependent
    values and arithmetic constraints.
    Thirdly,  the forward verifier infers temporal behaviors of given 
    \timedL\ programs, expressed in \timedEffects. 
    Lastly, we present a purely algebraic TRS, i.e., an extended \emph{Antimirov algorithm}, to 
    efficiently prove language inclusions between 
     \timedEffects. 
    To demonstrate the feasibility of our proposals, 
    we prototype the verification system; prove its 
    soundness; report on case studies and the experimental results. 
    
\end{abstract}


\begin{IEEEkeywords}
    Temporal Verification,
    Dependant Effects,
    Hoare-style Forward Verifier,
    Term Rewriting System,
    Timed Verification
\end{IEEEkeywords}


\section{Introduction}
\label{Introduction}


Specification and verification of real-time systems are essential 
to research topics with practical implications. During the last 
more than two decades, a popular approach for specifying real-time systems has been 
based on Timed Automata \cite{DBLP:journals/tcs/AlurD94}. 
Timed Automata are powerful 
in designing real-time models with explicit clock variables. Real-time 
constraints are captured by explicitly setting/resetting clock variables. 
A number of automatic verification support for Timed Automata have proven 
to be successful \cite{DBLP:journals/tse/WangSWQ17,DBLP:journals/sttt/LarsenPY97,DBLP:journals/sttt/Yovine97,DBLP:conf/seke/WangWH05}.


Models based on Timed Automata often adopt a simple structure, e.g., a 
network with no hierarchy. The benefit is that 
efficient model checking is made feasible. Nonetheless, designing and 
verifying compositional real-time systems is becoming an increasingly 
difficult task due to the widespread applications and increasing complexity 
of such systems. In industrial case studies of real-time system verification, system 
requirements are often structured into phases, which are then composed 
sequentially, in parallel and alternatively \cite{DBLP:conf/emsoft/LarsenMNS05}. 
Unlike timed process algebras, Timed Automata lack high-level 
compositional patterns for hierarchical design. As a result, users often 
need to manually cast those terms into a set of clock variables with 
carefully calculated clock constraints. The process is tedious and error-prone.



We investigate an alternative approach for modeling and verifying 
compositional real-time systems. In this work, 
we propose a novel temporal specification language, 
which enables a compositional verification via a  Hoare-style 
forward verifier and a term rewriting system (TRS). 
More specifically, we specify system behaviors in the form of 
{Timed Effects} (\timedEffects), which integrates the Kleene Algebra 
with dependent values and arithmetic constraints, 
%gaining the expressive power beyond finite-state machines; and (ii) introduces a new parallel operator 
to 
%capture the parallelism between event-triggered (sync) and  time-triggered (async) execution traces, 
provide real-time abstractions into traditional linear temporal logics. 
%Resource usages, provided by a \emph{dynamic ticks}\cite{DBLP:conf/fdl/HanxledenBG17}, incorporating the time-triggered (physical time) and event-triggered (logical time) execution loops. 
For example, one safety property, \textit{"The event \anyevent{Done} 
will be triggered no later than one time unit"}\footnote{Without loss of generality, 
we use integer values to represent time units in this 
paper.% while it can bes extended to real numbers and other 
%time measurement units.
}, is expressed in \timedEffects\ as: 
\begin{align*}
  \code{\effect \defeq \  0 {\leq} t {<}1 \wedge ({\_^\star} \cdot \anyevent{Done} ) \mysharp  t}
\end{align*}  
%The timed effects incorporates different kinds of existing temporal logics, such as linear-time temporal logic (LTL)
%and .
%which replaces temporal operators by time-constrained versions from 
Here, \code \wedge  connects the arithmetic formula and the timed trace, \code{\mysharp } is a novel operator specifying the \emph{real-time} 
constraints for the \emph{logical-time} sequences \cite{DBLP:conf/fdl/HanxledenBG17}; 
\code{\_} is a wildcard matching to any event; 
Kleene star \code{\star} denotes trace repetition.
The above formula \code{\effect} corresponds to `\code{\Diamond_{[0, 1)}\ }\anyevent{Done}' 
in metric temporal logic (MTL), reads \textit{"within one second, 
\anyevent{Done} finally happens"}. 

Moreover, the time bounds 
can be dependent on the program inputs, demonstrated in 
\figref{fig:Value_dependent_intro}; we mark the precondition and postcondition
using keywords {\color{darklavender}\code{\emph{req:}}} and {\color{darklavender}\code{\emph{ens:}}} respectively. 


\begin{wrapfigure}{L}{0.39\columnwidth}
\begin{lstlisting}[name=coffee]
void addOneSugar() 
/*req: true/\ _^*
  ens: t>1 /\ emp#t */ 
{ timeout ((), 1); }

void addNSugar (int n) 
/*req: true/\ _^*
  ens: d>=n/\ Sugar#d */
{ if (n == 0) { 
      event ["Sugar"];} 
  else {
      addOneSugar();
      addNSugar (n-1);}} 
\end{lstlisting}
\caption{Value-dependent specification.} 
\label{fig:Value_dependent_intro}
\vspace{0mm}
\end{wrapfigure}

The function \code{addNSugar} takes a parameter \code{n}, representing 
the portion of the sugar we need to add. When \code{n} 
equals to \code{0}, 
it simply raises an event \anyevent{Sugar} to mark the end of the process. 
Otherwise, it adds one portion of the sugar by calling
\code{addOneSugar()}, then recursively calls 
\code{addNSugar} with parameter \code{n-1}. 
The use of statement \lstinline|timeout(e, d)| is standard \cite{JSTO}, 
which executes a block of code \code{e} after the specified time \code{d}.
Therefore, the time spent on adding one portion of the sugar is 
no less than one time unit. Note that {\color{darklavender}\code{\emph{emp\#t}}} 
refers to an empty trace which takes time \code{t}. 

Both preconditions require no arithmetic constraints,   
and  have no temporal constraints upon 
the history traces. 
The postcondition of \code{addNSugar(n)} indicates that  the method 
generates a finite trace where \anyevent{Sugar} takes a no 
less 
than \code{d} time-units delay to finish. 

Although these examples are simple, they show the benefits of deploying 
value-dependent 
time bounds, which is beyond the capability of Timed Automata. Intuitively, if traditional Timed Automata define an 
\emph{exact} transition system, \timedEffects\ define 
a set (possibly infinite) of exact transition systems. 


Moreover, we deploy a Hoare-style forward verifier to 
soundly infer the actual behaviors of given programs 
concerning the well-defined operational semantics. 
This approach provides a 
\emph{direct} (opposite to the techniques which require 
 manual and remote modeling processes), 
  and modular compositional 
verification for real-time systems, which are not possible
by existing techniques. 




   


\begin{comment}
  we express, the effects of \code{addNSugar(d)} as:
\begin{align*}
&\code{\effect^{send (d)} \defeq \  (0 {<} d {\leq}5 \wedge  0 {\leq} t {<} d),  ({\anyevent{Send} \mysharp  t)} \cdot \anyevent{Done}}.
\end{align*}  
effects of \code{addNSugar(n)} as:
\code{(n{>}0  \wedge  t {\geq} n) : ({Sugar \mysharp  t)}}

\end{comment}



   %they already illustrate the gain of expressiveness from  existing temporal logics and traditional Timed Automata. 

%properties  





Having \timedEffects\ to be  the specification language, 
and the forward verifier to infer the program behaviors, 
we are interested 
in the following verification problem: 
Given a program \code{\mathcal{P}},
and a temporal specification \code{\effect^{\prime}}, does the inclusions 
\code{\effect^{\mathcal{P}} \CONTAIN \effect^{\prime}} holds\footnote{The 
inclusion relation $\CONTAIN$ is formally defined in \defref{Inclusion}.}? Typically, 
checking the inclusion/entailment between the concrete program effects \code{\effect^{\mathcal{P}}} and the valid traces \code{\effect^{\prime}} proves that: the program \code{\mathcal{P}} will never lead to unsafe traces which violate \code{\effect^{\prime}}.

Since the expressiveness of \timedEffects\ goes beyond 
finite-state automata, it is neither sufficient nor efficient to 
translate them 
into Timed Automata and reply on the solving engines of Timed Automata.
Therefore we 
develop a novel TRS, 
which  is inspired by Antimirov and Mosses’ algorithm\footnote{Antimirov and Mosses' 
algorithm was designed for deciding the inequalities of regular 
expressions based on an 
complete 
axiomatic algorithm of the algebra of regular sets.} \cite{DBLP:journals/tcs/AntimirovM95} but solving the 
language inclusions between more expressive \timedEffects.  

\begin{comment}
  several compositional ,  
are introduced to capture quantitative timing constraints.
The idea is to 


In this work, we study temporal verification of 
compositional real-time systems,



Existing automatic verification techniques massively rely on 
the Timed Automata which requires manually cast of clock variables with 
carefully calculated clock constraints. 

A TRS is a refutation method that normalizes expressions in such a way 
that checking their inclusion corresponds to an iterated process of 
checking the inclusion of their \emph{partial derivatives} 
\cite{antimirov1995partial}. 
Works based on such a TRS \cite{DBLP:conf/icfem/SongC20,DBLP:journals/tcs/AntimirovM95,DBLP:journals/ijfcs/AlmeidaMR09,DBLP:conf/fsttcs/KeilT14,DBLP:journals/jcss/Hovland12}  show its feasibility and suggest that this method is a better average-case algorithm than those based on the comparison of automata. 

This work targets timed temporal verification, and to the best of 
the authors' knowledge, it proposes the first algebraic TRS 
 for the real-time verification. 
\end{comment}



 In short, the main contributions of this work are:




\begin{enumerate}
\item \textbf{Language Abstraction:} we formally define 
a core language \timedL, by defining its syntax and operational semantics, 
generalizing the real-time systems with mutable variables and timed 
behavioral patterns. %, such as \emph{delay}, \emph{timeout}, \emph{deadline}.

\item \textbf{Specification Language:} we propose \timedEffects, 
by defining its 
syntax and semantics, gaining the expressive power beyond 
traditional modeling languages for real-time systems.


 

\item \textbf{Automated Forward Verifier:} we establish a sound axiomatic 
semantics to infer the 
temporal behaviors of given target programs.  The verifier triggers the back-end 
solver TRS. 


\item \textbf{An Efficient TRS:}
we present the rewriting rules to prove the inclusion relations between the inferred 
behaviors and the given temporal specifications, both in  \timedEffects. 



\item \textbf{Implementation and Evaluation:} we prototype the novel 
effects logic and the automated verification system, 
prove the soundness, report on case studies and experimental results. 




\end{enumerate} 




\section{Overview}\label{sec:Overview}

We now highlight our main methodologies, using the example shown 
in \figref{fig:overview_coffee} This example simulates a 
coffee machine, which dynamically adds sugar based on the user's input number.  


%\subsection{HipHop.js and Dependent Effects}
\subsection{\timedEffects}
As shown in \figref{fig:overview_coffee}, we define Hoare-triple 
style specifications (enclosed in 
\textcolor{darklavender}{\ttfamily{{/* ... */}}}) for each function, 
which leads to a compositional verification strategy, where static 
checking and timed temporal verification can be done locally. 



%columns=fullflexible
\begin{wrapfigure}{L}{0.47\columnwidth}
  %\vspace{-1mm}
\begin{lstlisting}[name=coffee]
void makeCoffee (int n)
/*req: n>=0 /\ _^* . Cup
  ens: (n<=t<=5 /\ t1<=3) /\
       (Sugar#t).(Coffee#t1) */
{ deadline (addNSugar(n), 5);
  deadline (event["Coffee"], 3);}  

int main ()
/*req: true/\emp
  ens: t<=8/\(((!Done)^*)#t).Done */ 
{ event["Cup"];
  makeCoffee (3);
  event["Done"];}
\end{lstlisting}  
   %   \vspace{-1mm}
\caption{To make coffee with three portions of sugar 
within eight time units.}\label{fig:overview_coffee}
 %        \vspace{0mm}
\end{wrapfigure}



The precondition of \code{makeCoffee} 
 specifies that the input integer value \code{n} is non-negative, and it requires that before entering into this 
function, this history trace must contain the event  
\anyevent{Cup} on the tail. Therefore, function calls to \code{makeCoffee} which 
do not satisfy the precondition lead to a failure of the verification. 
\code{makeCoffee} sets a 
five time-units deadline while calling 
\code{addNSugar} (defined in 
Fig. \textcolor{black}{\ref{fig:Value_dependent_intro}}),
 with argument \code{n}; then emits event \anyevent{Coffee} with
 a three time-units deadline. 


The precondition of \code{main} requires no arithmetic constraints 
on its inputs (expressed as \code{true}) and 
an empty history trace (denoted using \code{emp} or \code{\epsilon}).
The postcondition of \code{main} specifies 
that before the final \anyevent{Done} happens, there is no 
occurrence of \anyevent{Done} (\code{!A} refers to the 
negation of the event \code{A}). Moreover, the whole process takes 
no more than eight time-units to hit the final event. 


\timedEffects\ supports more features such as \emph{disjunctions}, 
\emph{guards} and \emph{parallelism}, etc., which can be found in 
\secref{subsec:Specification_language} and 
\secref{subsec:Specification_Semantics}.  
Note that directly from the specifications, we are aware of:  
(i) the branching properties: different arithmetic conditions on the input parameters lead to different temporal effects;
and (ii) the required history traces: by defining the prior effects 
in precondition. 
The examples 
already show that our  effects provide more detailed information than 
traditional timed verification, and in fact, it cannot be fully 
captured by any prior works \cite{DBLP:journals/tse/WangSWQ17,DBLP:journals/sttt/LarsenPY97,DBLP:journals/sttt/Yovine97,DBLP:conf/seke/WangWH05}.
Nevertheless, the gain in expressive power comes from the efforts 
of a more dedicated verification process, handled by our forward verifier and TRS.








\subsection{Forward Verification}
As shown in \figref{fig:forward_example}, we demonstrate the 
forward verification process of the functions \code{addOneSugar} and   {\code{addNSugar}}.
The current effects states are captured 
in the form of 
\code{\{ \textcolor{darklavender}{\effect_C} \}}. 
To facilitate the illustration, we label the verification 
steps by (1), ..., (11), and mark the deployed inference 
rules (cf. \secref{Forward_Rules}) in \textcolor{mGray}{[gray]}.
The verifier invokes the TRS to check language inclusions along the way.


\begin{comment}
  
/*require n>=0, _^*
  ensure  t>=n, Sugar#t */
{  
    
  
    
    
\end{comment}

{
\begin{figure}[!ht]
    %  \vspace{-4mm}
     \begin{minipage}[c]{\columnwidth}
         \centering
         {%\small
         \begin{enumerate}
\item \lstinline|void addOneSugar() {| \textcolor{mGray}{\footnotesize 
\quad \emph{// initialize the effects state using the function precondition \code{\effect_{pre}^{addOneSugar(n)}}.}} \\
\textcolor{darklavender}{\{\code{\effect_C {=}\effect_{pre}^{addOneSugar(n)} =  true \wedge  \_^\star \} }} 
\quad \siderule{\scriptsize[FV\text{-}Meth] } \\

\item ~\qquad \lstinline|timeout ((), 1);}| \\
\textcolor{darklavender}{\code{\effect_C^\prime {=} t_0{>}1   \wedge \_^\star \cdot \epsilon \mysharp t_0  }} 
\quad \siderule {\scriptsize [FV\text{-}Timeout]}
\item 
\textcolor{darkred}{\code{
%\code{(n{=}0 \wedge \anyevent{Done})\ \vee\ }\code{ (n  \neq 0  \wedge \anyevent{Send}\cdot \effect_{post}^{addNSugar(n-1)}) } 
\effect_C^\prime \CONTAIN \effect_{pre}^{addOneSugar(n)} \cdot \effect_{post}^{addOneSugar(n)} \Leftrightarrow  }} 
 %\textcolor{mGray}{  \emph{(-- check postcondition --) }}
 \textcolor{darkred}{\code{\code{\code{t_0{>}1   \wedge \epsilon \mysharp t_0}
 \CONTAIN t{>}1   \wedge \epsilon \mysharp t }}}
 \quad \textcolor{mGray}{\footnotesize  \emph{// TRS: postcondition checked. }}
 \\ 
%ens: t>1 /\ emp#t */ { 
  \noindent\rule{0.92\columnwidth}{0.4pt}
  \vspace{2mm}
~\\
\item \lstinline|void addNSugar (int n) {| \textcolor{mGray}{\footnotesize 
\quad \emph{// initialize the effects state using the function precondition \code{\effect_{pre}^{addNSugar(n)}}.}} \\
     \textcolor{darklavender}{\{\code{\effect_C {=}\effect_{pre}^{addNSugar(n)} =  true \wedge  \_^\star \} }} 
      \quad \siderule{\scriptsize[FV\text{-}Meth] } \\
     \item ~\qquad \lstinline|if (n == 0) {| \\
     \textcolor{darklavender}{\code{\{ n{=}0 \wedge  \_^\star \}  }} 
     \quad \siderule{\scriptsize [FV\text{-}If\text{-}Else]}
      \item ~\qquad~\qquad \lstinline|event ["Sugar"];} |  \\
     \textcolor{darklavender}{\code{\{n{=}0 \wedge   \_^\star \cdot Sugar\} }} 
     \quad \siderule{\scriptsize [FV\text{-}Event]}
     \item 
     ~\qquad \lstinline|else {| \\
     \textcolor{darklavender}{\code{\{ n  {\neq} 0 \wedge   \_^\star \}  }} 
     \quad \siderule{\scriptsize [FV\text{-}If\text{-}Else]}
    \item 
     ~\qquad~\qquad \lstinline|addOneSugar();| \\
     \textcolor{darklavender}{\code{\{n  {\neq} 0 \wedge  t{>}1  \wedge \_^\star \cdot \epsilon \mysharp t  }\}} 
     \quad \siderule {\scriptsize [FV\text{-}Call]}
     \item 
     ~\qquad~\qquad \lstinline|addNSugar (n-1);}}|  \\
     \textcolor{huntergreen}{\code{n  {\neq} 0   \wedge t{>}1  \wedge \_^\star \cdot \epsilon \mysharp t   \CONTAIN \effect_{pre}^{addNSugar(n\text{-}1)} }}
      \quad \textcolor{mGray}{\footnotesize  \emph{// TRS: precondition checked.}}
\\
     \textcolor{darklavender}{\code{\{n  {\neq} 0  \wedge t{>}1  \wedge \_^\star 
     \cdot \epsilon \mysharp t \cdot \effect_{post}^{addNSugar(n\text{-}1)} }\}} 
     \quad \siderule {\scriptsize [FV\text{-}Call]}
      \item \textcolor{darklavender}{\code{\effect_C^\prime {=} (n{=}0 \wedge  \_^\star \cdot Sugar)\ \vee\ }
      \code{ (n  {\neq} 0  \wedge t{>}1  \wedge \_^\star \cdot \epsilon \mysharp t \cdot \effect_{post}^{addNSugar(n\text{-}1)} ) }} 
      \quad \siderule{\scriptsize [FV\text{-}If\text{-}Else]}
      %\quad \siderule {\scriptsize [Normalization]}
      \\
       \item 
       %\textcolor{mGray}{  \emph{(-TRS: check the  postcondition; Succeed, cf. \autoref{tab:rewriting_tree_send}-) }}\\
       \textcolor{darkred}{\code{
       %\code{(n{=}0 \wedge \anyevent{Done})\ \vee\ }\code{ (n  \neq 0  \wedge \anyevent{Send}\cdot \effect_{post}^{addNSugar(n-1)}) } 
       \effect_C^\prime \CONTAIN \effect_{pre}^{addNSugar(n)} \cdot \effect_{post}^{addNSugar(n)} \Leftrightarrow  }}  
       \quad \textcolor{mGray}{\footnotesize  \emph{// TRS: postcondition checked, cf. \tabref{tab:rewriting_tree_send}. }}
        \\ 
        \textcolor{darkred}{\code{\code{\code{(n{=}0 \wedge Sugar)\ \vee\ }
        \code{ (n  {\neq} 0  \wedge  t{>}1  \wedge \epsilon \mysharp t \cdot \effect_{post}^{addNSugar(n\text{-}1)}) } \CONTAIN \effect_{post}^{addNSugar(n)}}}}\\
    
     
\end{enumerate}}

     \end{minipage}

      \caption{The forward verification example for method \code{send}. }\label{fig:forward_example}
     % \vspace{-4mm}
\end{figure}
}



The effects states (1) and (4) are obtained by initializing 
\code{\effect_C} from the precondition, by the \code{[FV\text{-}Meth]} rule. 
The effects states (5), (7), and (10) are obtained by  
\code{[FV\text{-}If\text{-}Else]}, which adds the constraints 
from the conditionals into the current effects state, 
and unions the effects accumulated from two branches in the end. 
The effects states (6) is obtained by \code{[FV\text{-}Event]}, 
which concatenates the triggered singleton event to the 
end of the current effects state. 

The intermediate effects states of (8) and (9) are obtained by \code{[FV\text{-}Call]}. 
Before each function call, it invokes the TRS to check whether the current effects state 
satisfies the precondition of the callee function. 
If it is not satisfied, the verification fails; otherwise, 
it concatenates the callee's postcondition to the current 
effects state (the precondition check for step (8) is omitted here).

The effects state (2) is obtained by \code{[FV\text{-}Timeout]}, 
which adds a lower time-bound to the trace. 
After these states transformations, steps (3) and (11) check the 
satisfiability of the inferred effects against the declared 
postcondition by invoking the TRS. 

Note that the prior effects in precondition are new regarding 
the existing real-time verification. 






\subsection{The TRS}

Our TRS is 
%obligated to check the inclusions between \effectNameSyncEffs, which is 
an extension of Antimirov and Mosses's algorithm. The rewriting system in {\cite{DBLP:journals/tcs/AntimirovM95}  
decides inequalities of regular expressions (REs) through an iterated process of checking the inequalities of their 
\emph{partial derivatives} \cite{antimirov1995partial}. There are two basic rules: 
$\code{[DISPROVE]}$, which infers false from trivially inconsistent inequalities; and  
$\code{[UNFOLD]}$, which applies \defref{RegularInclusion} to generate new inequalities.
In detail, given \code{\Sigma} is the whole set of the alphabet, 
\code{D_{\anyevent{A}}(r)} is the partial derivative of \code{r} w.r.t the event \code{\anyevent{A}}. 


\begin{definition}[REs Inequality]\label{RegularInclusion}  For REs \code{r} and \code{s}, \code{r \preceq s \Leftrightarrow \forall (\anyevent{A} \in \Sigma).\ D_{\anyevent{A}}(r) \preceq D_{\anyevent{A}}(s)}.
\end{definition}


\begin{definition}[\timedEffects\ Inclusion]\label{Inclusion}  %Let \code{\varrho} be the signal set. 
For \timedEffects\ \code{\effect_1 } and \code{\effect_2}, 
\code{\effect_1 { \CONTAIN} \effect_2 {\Leftrightarrow} \forall \anyevent{A}. \forall t {\geq} 0.\ D_{\anyevent{A} \mysharp  t}(\effect_1)  
{\CONTAIN} D_{\anyevent{A} \mysharp  t}(\effect_2)}.
\end{definition}
%\in fst(\effect_1)

Similarly, we defined the \defref{Inclusion} for unfolding the inclusions  
between \timedEffects, where \code{D_{\anyevent{A}\mysharp  t}(\effect)} 
is the partial derivative of \code{\effect} w.r.t the event 
\anyevent{A} and the time variable \code{t}. 



%Adapting to the context of checking inclusions between \timedEffects, we extend the Antimirov algorithm with 



%The rule \code{[REOCCUR]} finds the syntactic identity, as a companion, of the current open goal, as a bud, from the internal proof tree \cite{DBLP:conf/tableaux/Brotherston05}. (We use \code{\textcolor{persianplum}{(\dagger)}} in \tabref{tab:rewriting_tree_send} to indicate such pairings.)

%(introduce \code{t_L^1} and \code{t_L^2}, let \code{t_L^1 {+} t_L^2 {=} t_L}  


%(\code{\{Cook\} {\Rightarrow} \{Cook\}}, \code{t_L^1 {+} t_L^2 {<}3 {\Rightarrow} t_L^1 {<}3})

Next, we continue with the step (11) in \figref{fig:forward_example}, to 
demonstrate how the TRS handles arithmetic constraints and dependent values. 
%We use the postcondition proving for function \code{main} as an example to briefly demonstrate the rewriting process. 
As shown in \tabref{tab:rewriting_tree_send}, it automatically proves that the inferred effects of {\ttfamily{main}}
 satisfy the declared postcondition. 
%property \code{\effect_1  {=} 0{\leq} t {<}3 : \_\cdot(\{Cook\}\mysharp  t)\cdot\_^\star}, 
%where \code{\effect_1} simply indicates that the signal \anyevent{Cook} needs to happen at the second event, and takes no more than \code{3} time units after the first event has completed; and \code{\_^\star} means we do not care the rest of the traces. 
We mark the rewriting rules (cf. \secref{sec:Entailment_Prover}) in \textcolor{mGray}{[gray]}.



{
\begin{table*}[ht]
\centering
     % \vspace{0mm}
\caption{\label{tab:rewriting_tree_send} The inclusion proving example. 
\code{I:} The main rewriting proof tree; \code{II:} Right hand side sub-tree of the rewriting process.}
      
\vspace{-1mm}
\begin{adjustbox}{width=1\textwidth}
 \Large\begin{tabular}[t]{l}
  \hline\\

  \code{(I):}\quad
  
  {
\begin{prooftree}
\hypo{\text{\textcircled{4}}
  \code{\siderule{[\code{PROVE}]}}
}

\infer[dashed]1[]{ \code{\textcolor {darkred}{n{=}0} \wedge \epsilon 
\CONTAIN \textcolor {darkred}{t_r{\geq}0} \wedge \epsilon \mysharp t_r}}

%\textcolor{blue}{\code{\pi_u : true}}
\infer[dashed]1[{\textcircled{3}\siderule{[\code{UNFOLD}]}}]{ \code{ \textcolor {darkred}{n{=}0} \wedge \cancel{Sugar}
\CONTAIN \textcolor {darkred}{t_r{\geq}0} \wedge \cancel{Sugar \mysharp t_r}}}


\hypo{\qquad \code{(II)}}

\infer[dashed]2[{\textcircled{2}\siderule{[\code{LHS\text{-}OR}]}}]{\code{(\textcolor {darkred}{n{=}0} \wedge Sugar)\ \vee\ }
\code{ (\textcolor {darkred}{n  {\neq} 0  \wedge  t{>}1 \wedge t_l{\geq}(n\text{-}1)}  \wedge \epsilon \mysharp t \cdot 
 Sugar \mysharp t_l) } 
\CONTAIN \textcolor {darkred}{t_r{\geq}n} \wedge Sugar \mysharp t_r  }

\infer[dashed]1[{\textcircled{1}\siderule{[\code{RENAME}]}}]{\code{(\textcolor {darkred}{n{=}0} \wedge Sugar)\ \vee\ }
\code{ (\textcolor {darkred}{n  {\neq} 0  \wedge  t{>}1}  \wedge \epsilon \mysharp t \cdot \effect_{post}^{addNSugar(n\text{-}1)}) } 
\CONTAIN \effect_{post}^{addNSugar(n)}  }
\end{prooftree}}
\\~\\

\hline \\
\code{(II):} \quad\ \  

{\begin{prooftree}
  \hypo{
  \code{\textcolor {darkred}{  t{>}1 \wedge t_l{\geq}(n\text{-}1) 
   \wedge  \textcolor{blue}{t_r{=}t_r^1 {+}t \wedge  t_l{=}t_r^1}  \Rightarrow t_r{\geq}n
}  } 
 }

 \infer[dashed]1[{\textcircled{7}\siderule{[\code{PROVE}]}}]{ \code{ \textcolor {darkred}{n  {\neq} 0  \wedge  t{>}1 \wedge t_l{\geq}(n\text{-}1)}  \wedge 
 \epsilon
\CONTAIN \textcolor {darkred}{t_r{\geq}n} 
\wedge \epsilon}}

 \infer[dashed]1[{\textcircled{6}\siderule{[\code{UNFOLD}]}} \textcolor{blue}{\code{\pi_u :  (t_r{=}t_r^1 {+}t \wedge  t_l{=}t_r^1)}}]
 { \code{ \textcolor {darkred}{n  {\neq} 0  \wedge  t{>}1 \wedge t_l{\geq}(n\text{-}1)}  \wedge 
\cancel{ Sugar \mysharp t_l}
\CONTAIN \textcolor {darkred}{t_r{\geq}n} 
\wedge \cancel{Sugar \mysharp t_r^1}}}

 \infer[dashed]1[{\textcircled{5}\siderule{[\code{UNFOLD}]}} \textcolor{blue}{\code{\pi_u :  (t_r{=}t_r^1 {+}t)}}]
 { \code{ \textcolor {darkred}{n  {\neq} 0  \wedge  t{>}1 \wedge t_l{\geq}(n\text{-}1) } \wedge \cancel{\epsilon \mysharp t} \cdot 
 Sugar \mysharp t_l
\CONTAIN \textcolor {darkred}{t_r{\geq}n} \wedge Sugar \cancel{\mysharp t_r}}}

\end{prooftree}
}

\\~\\

\hline
    
\end{tabular}
\end{adjustbox}
      %      \vspace{0mm}
\end{table*}
}



As shown in \tabref{tab:rewriting_tree_send}, step 
\textcircled{1}, renames the time variables to avoid 
the name clashes between the antecedent and the consequent.  
Step \textcircled{2} splits the proof tree into two 
branches, according to the different 
arithmetic constraints, by rule  $\code{[LHS\text{-}OR]}$. 

In the first branch, step \textcircled{3} takes the rule 
$\code{[UNFOLD]}$ to eliminate the head of the antecedent. 
Step \textcircled{4} proves the inclusion, because 
evidently the consequent \code{t_r {\geq} 0 \wedge \epsilon \mysharp t_r} 
contains \code{epsilon} when \code{t_r{=}0}. 

In the second branch, step \textcircled{5} eliminates the 
head of the antecedent, where the head is a time duration \code{\epsilon\mysharp t}. 
Therefore the rule $\code{[UNFOLD]}$ subtract the time duration 
from the consequent, leaving a fresh time variable \code{t_r^1} and 
an unification constraint \textcolor{blue}{\code{\pi_u : t_r{=}t_r^1 {+}t}}. 
Similarly, step \textcircled{6} eliminates the head 
\code{\anyevent{Sugar}\mysharp t_l}, adding \textcolor{blue}{\code{t_l{=}t_r^1}} 
to the unification constraints. 
At the end of the rewriting, step \textcircled{7} manages to prove that 
\code{\textcolor {darkred}{  t{>}1 \wedge t_l{\geq}(n\text{-}1) 
\wedge  \textcolor{blue}{t_r{=}t_r^1 {+}t \wedge  t_l{=}t_r^1}  \Rightarrow t_r{\geq}n
}  } \footnote{The proof obligations generated by the verifier are discharged using constraint solver Z3 \cite{DBLP:conf/tacas/MouraB08}.}; therefore, the proof succeed.

%(\code{\{Go\} \Rightarrow \_})
%(\code{\{Ready\} \Rightarrow \_}, \code{t_L^2 \Rightarrow true})
Termination is guaranteed because the set of derivatives to be considered is finite, and possible cycles are detected using 
\emph{memorization} \cite{DBLP:conf/tableaux/Brotherston05}, cf.\ \tabref{tab:reoccur}. 


\subsection{Verifying the Fischer’s Mutual Exclusion Protocol}




\begin{wrapfigure}{L}{0.51\columnwidth}
  \vspace{-5mm}
\begin{lstlisting}
var x := -1; 
var ct:= -1;

void proc (int i) {
  [x=-1] 
  deadline(event["Update"(i)]{x:=i},d1);
  delay (d2);
  if (x=i) {
    event["Critical"(i)]{ct:=i};
    event["Exit"(i)]{ct:=-1; x:=-1};
    proc (i);
  } else {
    proc (i);}}

void main () 
/*req: d1<d2/\emp
  ens: true /\ (([ct=-1]\/[ct=x])^*) */ 
{ proc(0) || proc(1) || proc(2); }
\end{lstlisting}  
  %\vspace{-1mm}
  \caption{Fischer's mutually exclusion algorithm.}\label{fig:overview_ficher}
    % \vspace{-2mm}
\end{wrapfigure}

\figref{fig:overview_ficher} presents the classical 
Fischer's mutually exclusion algorithm. 
where \code{d1} and \code{d2} are two integer constants
 with \code{d1<d2}; 
\code{x} and \code{ct} are global variables. The protocol is 
modeled as 
process protocol, which is the parallel composition of three 
processes. Each of the three processes attempts to enter 
the critical section when \code{x} is \code{-1}, i.e. no 
other process is 
currently attempting. Once the process is active, it sets \code{}{x} 
to its identity \code{i} within \code{d1} time units (captured by \code{deadline(..., d1}). 
Then it idles for \code{d2} time units (captured by \code{delay(d2)}) and then 
checks whether \code{x} is still \code{i}. If so, 
it enters the critical 
section and leaves later. Otherwise, it restarts from the 
beginning.  

We show the specification of \code{main} using \timedEffects, which
restricts the relation between \code{d1} and \code{d2}. When 
\code{d1<d2} is provided, it ensures a global state, i.e., the repeated trace, where the value of 
\code{ct} is either \code{-1} or equals to \code{x}. The specification
implies that this implementation is indeed mutual exclusive. 
Our prototype system is able to soundly check such time-critical 
algorithms. \secref{sec:Evaluation} presents the details about the implementation and evaluation.


\section{Language and Specifications}
\label{sec:LanguageSpecifications}

\subsection{The Target Language}
\label{subsec:Targetlanguage}

To formulate the target language, we generalize the design of the real-time systems
 into a core language \code{\timedL}, 
 which provides the infrastructure for mutable variables and timed behavioral patterns, 
 such as \emph{delay}, \emph{timeout}, \emph{deadline}. 
We here formally define the syntax of \code{\timedL}, as shown in \figref{fig:code_language} 




{
 % \vspace{-2mm}
\begin{figure}[!ht]
\renewcommand{\arraystretch}{1.1}
\centering%\small
  $
  \begin{array}{lrcl}

    \m{(Program)} &  \code{\mathcal{P} }&\code{  ::= }&
    \code{%{datat^*}  \  
   (\alpha^*, {meth^*})} 
    \\


    \m{(Basic\ Types)} &   \code{\iota} &\code{  ::=  }&
     \code{int\ |\ bool\ |\ void}

    \\
%     \m{(Data\ Struct.)} &  \code{datat}&\code{  ::= }&
 %    \code{\textbf{struct}\ d\ \{ {(t\ f)^*} \}}  
 %   \\

  
  \m{(Method\ Def.)} &  \code{meth}&\code{ ::= }&
  \code{\iota\  mn  \ {(\iota\ x)^*}\ \{\textbf{req}\ \effect_{pre}\ \textbf{ens}\  \effect_{post}\} \ \{ e \}}
  \\
  \m{(Values)} & \code{v} &\code{  ::= } & ()\ |\ c \ | \ b \ |\ x\  
  \\


  \m{(Assignment)} &  \code{\alpha }&\code{  ::= }&
  \code{x:=v} 
 \\
  \m{(Expressions)} &  \code{e}&\code{  ::= }&
    \code{ v \ 
    | \ \alpha \ | \ 
    [b]\ e \ |\ mn({v^*}) \ }
  \code{|  \ e_1;e_2\ | \ e_1 || e_2 \ 
  |\ {if}\ b\ {then}\ e_1\ {else}\ e_2 \
 }  \\

 &   & & \code{
  |\ \textbf{event} [\anyevent{A}(v, \alpha^*)] \ 
  | \ \textbf{delay} [t] \ 
  | \ e_1\ \textbf{interrupt} [t] \  e_2 \ 
  }  \\
  
  &   & & \code{
    | \ e_1\ \textbf{timeout} [t] \  e_2 \ 
    | \ e \ \textbf{deadline}  [t] \ 
    | \ e \ \textbf{waituntil} [t]  \ 
    }  \\

    \m{(Real\text{-}Time\ Terms)}  & \code{t} &\code{  ::= }&
    \code{ c
    \ | \  x
    \ | \  t_1{+}t_2
    \ | \  t_1\text{-}t_2
   }
  
    \\
    ~\\

 
 
    \multicolumn{4}{c}{
 % \code{k^\tau:constant\ of\ type\ \tau\ } 
 % \qquad\quad
\code{c  \in \mathbb{Z}}
\qquad \qquad 
\code{b  \in \mathbb{B}}
\qquad \qquad  
\code{x, mn  \in \textbf{var}}  
\qquad \qquad 
 \code{(Action\ labels)\ \anyevent{A}  \in \Sigma %\cup \{\tau\}
%\qquad\ 
%\m{(Time\ Bounds)}\ \code{d} \code{\in \mathbb{N}}    
}   
    }\\  
    \hline
  \end{array}  
  $
 \caption{A core first-order imperative language with timed constructs, \timedL.} 
 \label{fig:code_language}
  
\end{figure}
}

Here, \code{c} and \code{b} are for integer and Boolean constants, 
 \code{mn} and \code{x} are for meta-variables.  
 \textbf{var} represents the countably infinite set of arbitrary distinct identifiers. 

A program \code{\mathcal{P}} comprises a list of 
global-variable initializations \code{\alpha^*} and 
a list of 
method declarations \code{{meth^*}}. 
Here, we use the \code{*} superscript to denote a finite list (possibly empty) of items, for example, \code{{x^*}} refers to a list of variables, \code{x_1, ...,\ x_n}. 
%Besides, \code{d} denotes the name of a user-defined data type, \code{f} denotes a field name. 
Each method \code{meth} has a name \code{mn}, an expression-oriented body \code{e}, also is associated with a precondition  \code{\effect_{pre}} and a postcondition \code{\effect_{post}} (the syntax of effects specification \code{\effect} is given in \figref{fig:Syntax_of_Types_and_Effects}).
The language allows each iterative loop to be optimized to an equivalent 
tail-recursive method, where mutation on parameters is made visible 
to the caller. 
%The technique of translating away iterative loops is standard
%\citeref{insa2015automatic} 
%and is helpful

Expressions comprise simple values \code{v};
a guarded process is written as \code{[b]e} where if \code{b} is true, 
then it behaves as \code{e}, else it idles until \code{b} becomes true; 
%one-level field access \code{v.f} (rather than \code{v.f1.f2...} for the sake of simplicity), 
%data structure allocation \code{\textbf{new}\ d({v^*})},  
%local variable declaration \code{\alpha; e}, 
method calls \code{mn({x^*})}; 
%variable assignments \code{\alpha}; 
%field update \code{v.f:=e}, 
expression sequences \code{e_1;e_2};
parallel composition \code{e_1 || e_2}, where \code{e_1} and \code{e_2} 
may communicate via multi-party event synchronization or shared variables; 
conditional expressions \code{{if}\ v\ {then}\ e_1\ {else}\ e_2}. 

The expression \code{ \textbf{event} [\anyevent{A}(v,  \alpha^*)] } 
raises an event \anyevent{A}, which comes from the finite 
set of event labels \code{\Sigma}. %or can be an invisible event, denoted by $\tau$. 
Without loss of generality, events can be further parametrized with 
one constant value \code{v} and a set of assignments \code{\alpha^*} upon 
the mutable variables. %e.g. \code{\anyevent{a}.0} and  \code{\anyevent{a}}.1 are distinct two events. 
%leading to infinite alphabet.
%We assume that programs we use are well-typed conforming to basic types \code{\tau} (we take () as the \code{void} type).
%Each events raising expression \code{\textbf{event}} is parametrized with an event, to trigger such a single event. 


%parametrized with \code{v}, 
%and takes a set of 
%assignment actions \code{\alpha^*}. 

Furthermore, a number of timed process constructs can be used to capture common 
real-time system behavior patterns. Without loss of generality, we 
assume \code{d} is a non-negative integer constant.  
$\textbf{delay} [d]$ idles for exactly $d$ 
time units.
 In process $e_1\ \textbf{timeout} [d]\ e_2$, the first observable event of 
$e_1$ shall occur before d time units elapse (since the process starts). 
Otherwise, $e_2$ takes over control after exactly $d$ time units elapse. 
Note that the usage of timeout in \figref{fig:Value_dependent_intro} is a 
special case of the primitive presented here, where \code{e_1} never starts. 
Process $\textbf{deadline} [d]\ e$ constraints $e$ to terminate before $d$ time units. 


In this setting, clock variables are 
made implicit and hence they cannot be compared with each other 
directly, which potentially allows efficient clock manipulation and 
hence system verification.


%

\subsection{Semantics of the target language}
\label{subsec:Targetlanguage_Semantics}

In order to define the operational semantics of a system model, 
we define the notion of a configuration, in \defref{sys_configuration}, to capture 
the global system state during system execution.

\begin{definition}[System configuration]\label{sys_configuration}
A system configuration \code{\zeta} is a pair $(\env , e)$ where $\env$ is a variable valuation function and $e$ is an expression.
\end{definition}

A transition of the system is of the form $\zeta \xrightarrow[]{l} \zeta^\prime$ 
where $\zeta$ and $\zeta^\prime$ are 
the system configurations before and after the transition respectively. 
%There are four type of the transition labels  :
We adopt the following naming convention \cite{DBLP:conf/icfem/SunLDZ09} for the transition labels \code{l}: 
(1) $t$, denoting a non-negative real integer; 
(2) $\tau$, denoting an invisible event; % which do not make changes to the global valuation;
(3) $\anyevent{A}$ is an observable event. 
%and (4) $\sigma \in \Sigma\cup \{\tau\}$. 
For example, $\zeta \xrightarrow[]{\text{t}} \zeta^\prime$ denotes a transition 
of \code{t} time-units elapsing. 
In the following, we present the firing rules which are associated with 
the timed process constructs. 

\input{rules/op_delay.tex}

The above captures behaviors of process \textbf{delay}[d]. 
Rule \code{[delay_1]} states that the process may idle for 
any amount of time as long as it is less than or equal to \code{d} time units; 
Rule \code{[delay_2]} states that the process terminates immediately after 
\code{d} becomes \code{0}.

\input{rules/op_to.tex}

If an observable event \anyevent{A} can be engaged by \code{e_1}, 
then $e_1\ \textbf{timeout}[d]\ e_2$ becomes \code{e_1^\prime} (rule \code{[tot_1]}). 
An invisible transition continues the waiting on \code{e_1} (rule \code{[tot_2]}). 
If \code{e_1} may idle for less than or equal 
to \code{d} time units, so is the composition (rule \code{[tot_3]}). 
When \code{d} becomes \code{0}, 
\code{e_2} takes over control by a silent transition (rule \code{[tot_4]}).

\input{rules/op_ddl.tex}

Intuitively, $\textbf{deadline}\  [d] \ e$ behaves exactly as 
\code{e} except that it must terminate before \code{d} time units.


\input{rules/op_gu.tex}



The guarded process \code{[b]e} behaves as \code{e} when \code{b} is true, 
otherwise it idles until \code{b} becomes true. 

{{\small\begin{flalign*}
\code{\frac{
  (\env,e_1) \xrightarrow[]{l} (\env^\prime,e_1^\prime) 
}{(\env, e_1; e_2 ) \xrightarrow[]{l} (\env^\prime, e_1^\prime ; e_2)}\ [seq_1]} 
\qquad
\code{\frac{
}{(\env, (); e_2 ) \xrightarrow[]{\tau} (\env, e_2)}\ [seq_2]} 
\qquad
\code{\frac{
  (\env,e_1) \xrightarrow[]{l} (\env^\prime,e_1^\prime) 
}{(\env, e_1 || e_2 ) \xrightarrow[]{l} (\env^\prime, e_1^\prime || e_2)}\ [par_1]} 
\\ 
  \code{\frac{
    (\env,e_2) \xrightarrow[]{l} (\env^\prime,e_2^\prime) 
  }{(\env, e_1 || e_2 ) \xrightarrow[]{l} (\env^\prime, e_1 || e_2^\prime)}\ [par_2]} 
  \qquad \qquad 
  \code{\frac{
    (\env,e_1) \xrightarrow[]{t} (\env,e_1^\prime) 
    \qquad 
    (\env,e_2) \xrightarrow[]{t} (\env,e_2^\prime) 
  }{(\env, e_1 || e_2 ) \xrightarrow[]{t} (\env, e_1^\prime || e_2^\prime)}\ [par_3]} 
\end{flalign*}}}

Rules \code{[seq_1]} and \code{[seq_2]} state that \code{e_1} takes the control 
when it still can behave; then the control transfers to \code{e_2} when \code{e_1}
terminates. Rules \code{[par_1]} and \code{[par_2]} state that in a parallel composition, 
if any of \code{e_1} or \code{e_2} can proceed, they proceed on their own. Rule 
\code{[par_3]} states that if both of the branches idle, they idle together. 




\subsection{The Specification Language}
\label{subsec:Specification_language}

We plant the effects specifications into the Hoare-style verification system, using \code{ es_{pre}} and \code{  es_{post} }  to capture the temporal pre/post 
condition. %\code{es_{pre}} and the postcondition \code{es_{post}}.

{
    \vspace{0mm}
\begin{figure*}[ht]
\renewcommand{\arraystretch}{1.1}
\centering
  $
  \begin{array}{rrcl}

 
    \m{(Timed\ Effects)} &  \effect &\code{  ::= }&
    \code{
          {\pi} \wedge \es
   \ | \ \effect_1 \vee \effect_2
}
    \\
 \m{(Event \ Sequences)}  & \ \code{\es}   &\code{ ::=}&
   
   \code{ \bot 
   \  | \  \epsilon 
    \ | \ \ev
   \  | \ \es_1 \cdot \es_2
    \ | \ \es_1 \vee \es_2
    \ | \ \es_1 {||} \es_2
    \ | \ \pi ? 
      %    \  | \ \es_1 \times \es_2
      \ | \ \es \mysharp  t 
   \  | \  \es^\star
}

\\
\m{(Events)} & \ev  &  ::=  & 
\code{
  \anyevent{A}(v, \alpha^*)
    \ | \ \tau (\pi)
    \ | \ \anynotevent{A} 
    \ | \ \_  
}
           

\\
    
    \m{(Pure)}  & \code{\code{{\pi}}}&\code{  ::= }&
{ {True}}
   \ |\  {False}
   \ |\  {A(}{t_1, t_2}{)}
  \  |\   {{\pi_1}}  \wedge  \code{{\pi}}_2
   \ |\  {{\pi_1}} {\vee} \code{{\pi}}_2
   \ |\  \neg\code{{\pi}}
  \  |\   {{\pi_1}} {\Rightarrow} {{\pi_2}}
  % \ |  \forall x. \code{{\pi}}
  %s \ |  \exists x. \code{{\pi}}

    
    \\
    

    
    \m{(Real\text{-}Time\ Terms)}  & \code{t} &\code{  ::= }&
    \code{ c
    \ | \  x
    \ | \  t_1{+}t_2
    \ | \  t_1\text{-}t_2
    %\ | \ k {\times} n
   }
 
    \\~\\
    \multicolumn{4}{c}{
     % \code{(Events)  \anyevent{A} ::\in \Sigma}   
   %\qquad
    \code{c \in \mathbb{Z}} 
     \qquad \qquad 
           \code{x  \in \textbf{var} } 
           \qquad\qquad 

     \m{(Real\ Time\ Bound)}\ \code{\mysharp }
     \qquad \qquad 
        \m{(Kleene\ Star) \ \star}    
        
}\\     
      \hline
    
  \end{array}  
  $ \\
  \caption{Syntax of \timedEffects.}
  \label{fig:Syntax_of_Types_and_Effects}
  \vspace{0mm}
\end{figure*}

}


The  syntax of the \timedEffects\ is formally defined in 
\figref{fig:Syntax_of_Types_and_Effects} Effects is 
 a conditioned event sequence \code{{\pi}\wedge es} or a disjunction of 
 two effects $\effect_1 \vee \effect_2$.
Timed sequences comprise \textit{nil} ($\bot $);
 an empty trace $ \epsilon$;
a single event \code{ev};
 sequences concatenation \code{\es_1\cdot \es_2};
disjunction  \code{\es_1\vee \es_2};
parallel composition of two processes is written as \code{\es_1 || \es_2}, where \code{\es_1} and \code{\es_2} 
may communicate via multi-party event synchronization or shared variables;
a blocking waiting for a certain constraint to be satisfied \code{\pi ?}; 
We introduce a new operator \code{\mysharp }, and the effects 
\code{\es \mysharp t} represents that a trace takes real-time 
\code{t} to complete, where \code{t} is a \emph{term}. 
A timed sequence can be constructed by \code{\es^\star}, representing zero or 
more times repetition of the trace \code{\es}.

\anyevent{A}\code{(v, \alpha^*)} stands for an observable event with label 
\anyevent{A}, parameterized by \code{v}, and the assignment operations \code{\alpha^*}; and 
\code{\tau(\pi)} is an invisible event, which can be parameterized with a pure formula 
\code{\pi}\footnote{The difference between 
\code{\tau(\pi)} and \code{\pi?} is \code{\tau(\pi)} leads to false (\code{\bot}) if 
\code{\pi} is not satisfied, whereas  \code{\pi?} waits until \code{\pi} is satisfied.}. 
To make the specification more practical, events can also be 
{\anynotevent{A}}, referring to those events which are not 
labeled using \anyevent{A}; and a wildcard \code{\_}, which matches to all the events.



We use \code{{\pi}} to denote a pure formula which captures the (Presburger) arithmetic conditions on terms or program parameters. 
We use \code{{A(}{t_1, t_2}{)}} to represent atomic formulas of two terms (including $  {=},
   \ {>},
   \ {<},
   \ {\geq}\ $ and $ {\leq} $).
%e.g. the equality between constant 0 and an integer variable \code{x}.
A term can be a constant integer value \code{c}, an integer variable \code{n} which is an input parameter of the program and can be constrained by a pure formula. 
A term also allows simple computations of terms, \code{t_1{+}t_2} and \code{t_1\text{-}t_2}. To abstract the elapsed time, the default and implicit pure constraints of all the terms is to be greater or equal to  0. 


\subsection{Semantic Model of Timed Effects}
\label{subsec:Specification_Semantics}

To define the model, 
\code{var} is the set of program variables, 
\code{val} is the set of primitive values, 
\code{\es} is the set of event sequences (or event multi-trees, per se), 
indicating the sequencing constraints on temporal behaviors.

Let \code{d, s, \varphi \models \effect} denote the model relation, i.e., 
the effects \code{\effect} take \code{d} time units to complete; 
the stack \code{s} and linear temporal events \code{\varphi} satisfy the 
temporal effects \code{\effect}, with \code{d}, \code{s}, \code{\varphi} 
from the following concrete domains: \code{d}  :\  \code{\mathbb{N}}, 
\code{s}  :\  \code{var {\rightarrow} val } and \code{\varphi}   :\ \code{\es} \ .


\begin{figure}[!ht]
  %\vspace{-3mm}
  \renewcommand{\arraystretch}{1.2}
\small\begin{align*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%     Disjunction        %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
&\code{d, s, \varphi \models \effect_1 \vee \effect_2}  
&\m{iff}\quad & \code{d, s, \varphi \models \effect_1 } \ 
or\ \code{d, s, \varphi \models \effect_2 }  \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%         Empty          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
&\code{d, s,  \varphi \models {\pi} \wedge  \epsilon}  
&\m{iff}\quad & \code{d{=}0}\ and  \ \code{\llbracket {\pi} \rrbracket_s {=}  
{True} } \ and\  \code{ \varphi {=} [] }\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%         Event          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
&\code{d, s, \varphi \models {\pi} \wedge \ev }  
&\m{iff}\quad & \code{d{=}0}\ and  \ \code{\llbracket {\pi} \rrbracket_s {=}  
{True} }\ and \ \varphi {=} [\ev]  \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%     Concatenate        %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
&\code{d, s, \varphi \models {\pi} \wedge (\es_1\cdot \es_2)}  
&\m{iff}\quad & \exists \code{\varphi_1,\varphi_2}. \  
\code{ \varphi_1 {\lappend} \varphi_2 {=} \varphi}\ and\ 
\exists \code{d_1,d_2}. \  
\code{ d_1 {+} d_2 {=} d} \\
&&& \qquad  s.t. \ \code{d_1, s, \varphi_1 {\models} {\pi}  \wedge \es_1 }
\ and \ \code{d_2, s, \varphi_2 {\models} {\pi}  \wedge \es_2 }\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%    disjunction         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
&\code{d, s, \varphi \models {\pi} \wedge (\es_1{\vee}\es_2)}  
&\m{iff}\quad & 
\code{d, s, \varphi \models {\pi}  \wedge \es_1 } 
\ or\  
\code{d, s, \varphi \models {\pi}  \wedge \es_2 } \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%    parallel         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
&\code{d, s, \varphi \models {\pi} \wedge (\ev_1 \cdot \es_1)||(\ev_2 \cdot \es_2)}  
&\m{iff}\quad & \code{d, s, \varphi \models {\pi}  \wedge \ev_1 \cdot  (\es_1||(\ev_2 \cdot \es_2)) } 
\ or\ \code{d, s, \varphi \models {\pi}  \wedge \ev_2 \cdot ((\ev_1 \cdot \es_1)||\es_2)  } \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%    parallel  2        %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
&\code{d, s, \varphi \models {\pi} \wedge (\ev\mysharp t_1) || (\epsilon \mysharp  t_2)}  
&\m{iff}\quad & \code{d, s, \varphi \models {(\pi \wedge t_1 {\geq}t_2)} \wedge (\ev\mysharp t_1) } 
\ or\ \code{d, s, \varphi \models {(\pi \wedge t_1 {<}t_2)}  \wedge (\ev\mysharp t_1) \cdot (\epsilon \mysharp  (t_2\text{-}t_1))  } \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%    block         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
&\code{d, s, \varphi \models {\pi} \wedge \pi_1 ? \es}  &\m{iff}\quad & 
\code{\llbracket \pi_1  \rrbracket_{s} {=}  
 {True} }, \ \code{d, s, \varphi \models {\pi}  \wedge \es}\ or  \ 
  \code{\llbracket \pi_1 \rrbracket_{s} {=}  
{False} }, 
\  \code{d, s, \varphi \models {\pi} \wedge \pi_1 ? \es}\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%    t times         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
&\code{d, s, \varphi \models {\pi}  \wedge \es\mysharp  t}  &\m{iff}\quad &
 \code{\llbracket {\pi}  \wedge t {=} 0 \rrbracket_{s} {=}  
 {True} }, \ \code{d, s, \varphi \models {\pi}  \wedge  \epsilon}\ or  \\
& & &  \code{\llbracket {\pi}\wedge t {>} 0 \rrbracket_{s} {=}  
{True} }, 
\  \exists \code{\es_1,\es_2}. \  \code{\es_1  \cdot  \es_2 {=} \es}, \  \m{fresh}\ t_1, t_2,\\
&&& \qquad  s.t. \ \code{d, s, \varphi {\models} {(\pi 
 \wedge  t_1{\geq}0 \wedge t_2{\geq}0  \wedge  t_1{+} t_2{=}t)} \wedge 
(\es_1\mysharp t_1)  \cdot  (\es_2\mysharp t_2) } \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%    star         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
&\code{d, s, \varphi \models {\pi}\wedge \es^\star}  &\m{iff}\quad & 
\code{d, s, \varphi \models {\pi}  \wedge  \epsilon}\ or \ 
\code{d, s, \varphi \models {\pi}  \wedge \es  \cdot  \es^\star}\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%    FALSE         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
& \code{d, s, \varphi \models false}  &\m{iff}\quad &
 \code{\llbracket {\pi}  \rrbracket_{s} {=} {False} } \ or \ \code{\varphi {=} \bot }
\end{align*}
 % \vspace{-2mm}
\caption{Semantics of \timedEffects.}
\label{fig:Sementic}
%\vspace{-2mm}
\end{figure}






As shown in \figref{fig:Sementic}, we define the semantics of our effects. 
We use $\lappend$ to represent the append operation of two event sequences. 
We use $[]$ to describe the empty sequence, \code{[\ev]} to represent 
the sequence that only contains one singleton event. 
Notice that, except for the traces constructed by \code{\mysharp}, simple events 
are taken to be happening in instant time. 



\bibliographystyle{IEEEtranN}
\bibliography{references}



\end{document}
